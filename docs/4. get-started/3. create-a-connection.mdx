---
id: create-a-connection
title: Create a Connection
slug: /get-started/create-a-connection/
sidebar_label: Create a Connection
sidebar_position: 3
---


## Connecting to the app

We have to make sure that the user is connecting to the application using a wallet. In our example we will write the logic for the connection to the application using MetaMask, one of the most popular wallets out there.

Connecting to the application is a simple process that can be accomplished with just a few lines of code and we'll create a `ConnectButton` component for that:

1. Write a simple `isMetaMaskInstalled` check function to verify that the user has the MetaMask wallet installed:

```jsx title="/src/components/ConnectButton.tsx"
// highlight-start
declare global {
  interface Window {
    ethereum: Provider;
  }
}

interface Provider {
  isMetaMask: boolean;
  request: (request: { method: string; params?: Array<any> }) => Promise<any>;
}
// highlight-end

function ConnectButton() {
  // highlight-start
  // Check function if MetaMask is installed
  const isMetaMaskInstalled = () => {
    const { ethereum } = window;
    return Boolean(ethereum && ethereum.isMetaMask);
  };
  // highlight-end

  const handleOnClick = async () => {
    if (isMetaMaskInstalled()) {
      // Request to connect to MetaMask
      try {
        const accounts = await window.ethereum.request({
          method: "eth_requestAccounts"
        });
        alert(`Connected with: ${accounts[0]}`);
      } catch (error) {
        console.error(error.message);
      }
    } else {
      alert("Please install MetaMask.");
    }
  };

  return (
    <button className="connectButton" onClick={handleOnClick}>
      Connect wallet
    </button>
  );
}

export default ConnectButton;
```

2. Write the logic inside `handleOnClick` for sending a request to MetaMask and, if successful, alert with the wallet address the user is connecting with:

```jsx title="/src/components/ConnectButton.tsx"
declare global {
  interface Window {
    ethereum: Provider;
  }
}

interface Provider {
  isMetaMask: boolean;
  request: (request: { method: string; params?: Array<any> }) => Promise<any>;
}

function ConnectButton() {
  // Check function if MetaMask is installed
  const isMetaMaskInstalled = () => {
    const { ethereum } = window;
    return Boolean(ethereum && ethereum.isMetaMask);
  };

  // highlight-start
  const handleOnClick = async () => {
    if (isMetaMaskInstalled()) {
      // Request to connect to MetaMask
      try {
        const accounts = await window.ethereum.request({
          method: "eth_requestAccounts"
        });
        alert(`Connected with: ${accounts[0]}`);
      } catch (error) {
        console.error(error.message);
      }
    } else {
      alert("Please install MetaMask.");
    }
  };
  // highlight-end

  return (
    <button className="connectButton" onClick={handleOnClick}>
      Connect wallet
    </button>
  );
}

export default ConnectButton;
```

3. Let's finish up our code by assigning the `handleOnClick` function you've written in the previous step to the `onClick` handler on the `button`:

```jsx title="/src/components/ConnectButton.tsx"
declare global {
  interface Window {
    ethereum: Provider;
  }
}

interface Provider {
  isMetaMask: boolean;
  request: (request: { method: string; params?: Array<any> }) => Promise<any>;
}

function ConnectButton() {
  // Check function if MetaMask is installed
  const isMetaMaskInstalled = () => {
    const { ethereum } = window;
    return Boolean(ethereum && ethereum.isMetaMask);
  };

  const handleOnClick = async () => {
    if (isMetaMaskInstalled()) {
      // Request to connect to MetaMask
      try {
        const accounts = await window.ethereum.request({
          method: "eth_requestAccounts"
        });
        alert(`Connected with: ${accounts[0]}`);
      } catch (error) {
        console.error(error.message);
      }
    } else {
      alert("Please install MetaMask.");
    }
  };

  return (
    // highlight-start
    <button className="connectButton" onClick={handleOnClick}>
      Connect wallet
    </button>
    // highlight-end
  );
}

export default ConnectButton;
```

That's it! Our `ConnectButton` component is now completed! You can check out the result for yourself in the sandbox below:

<iframe src="https://codesandbox.io/embed/get-started-fvecwy?fontsize=14&hidenavigation=1&theme=dark"
  title="get-started"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

## Create a follow button

Now our focus will turn on creating a connection and for that you'll need to create a `FollowButton` component that will handle the logic for that:
1. Install the `@cyberlab/cyberconnect` SDK:

```bash npm2yarn
npm install @cyberlab/cyberconnect
```

2. Import from the SDK `CyberConnect`, `Env` and `Blockchain` in your application:

```jsx
import CyberConnect, {
  Env,
  Blockchain,
} from '@cyberlab/cyberconnect';
```

3. In order to create a connection you'll first have to instantiate  `CyberConnect` and pass it the following variables: `namespace`, `env`, `chain` and `provider`:

```jsx title="/src/components/FollowButton.tsx"
import CyberConnect, { Env, Blockchain } from "@cyberlab/cyberconnect";

declare global {
  interface Window {
    ethereum: Provider;
  }
}

interface Provider {
  isMetaMask: boolean;
  request: (request: { method: string; params?: Array<any> }) => Promise<any>;
}

// highlight-start
const cyberConnect = new CyberConnect({
  namespace: "CyberConnect",
  env: Env.PRODUCTION,
  chain: Blockchain.ETH,
  provider: window.ethereum
});
// highlight-end

function FollowButton() {
  const handleOnClick = async () => {
    // Prompt to enter the address
    const address = prompt("Enter the ens/address to follow:");

    try {
      await cyberConnect.connect(address);
      alert(`Success: you're following ${address}!`);
    } catch (error) {
      console.error(error.message);
    }
  };

  return (
    <button className="followButton" onClick={handleOnClick}>
      Follow address
    </button>
  );
}

export default FollowButton;
```

:::note

You'll have to declare both `Window` and `Provider` interfaces in order to be able to read the `window.ethereum` provider and pass it as an argument.

:::

4. Using the same approach as the one with `ConnectButton`, now will write the logic for the connection (a.k.a. follow) inside the `handleOnClick` function and assign it to the `onClick` handler on the `button` element:

```jsx title="/src/components/FollowButton.tsx"
import CyberConnect, { Env, Blockchain } from "@cyberlab/cyberconnect";

declare global {
  interface Window {
    ethereum: Provider;
  }
}

interface Provider {
  isMetaMask: boolean;
  request: (request: { method: string; params?: Array<any> }) => Promise<any>;
}

const cyberConnect = new CyberConnect({
  namespace: "CyberConnect",
  env: Env.PRODUCTION,
  chain: Blockchain.ETH,
  provider: window.ethereum
});

function FollowButton() {
  // highlight-start
  const handleOnClick = async () => {
    // Prompt to enter the address
    const address = prompt("Enter the ens/address to follow:");

    try {
      await cyberConnect.connect(address);
      alert(`Success: you're following ${address}!`);
    } catch (error) {
      console.error(error.message);
    }
  };
  // highlight-end

  return (
    // highlight-start
    <button className="followButton" onClick={handleOnClick}>
      Follow address
    </button>
    // highlight-end
  );
}

export default FollowButton;
```

That's a wrap! Your `FollowButton` is now complete and your users are able to connect with other addresses on the Ethereum network. You can play around with the code in the sandbox:

<iframe src="https://codesandbox.io/embed/follow-button-kldd5u?fontsize=14&hidenavigation=1&theme=dark"
  title="follow-button"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Congrats! You've officialy created your first connection using the CyberConnect SDK! ðŸŽ‰

You're now ready to move on to the next step and implement the Social Verifier in your application.

